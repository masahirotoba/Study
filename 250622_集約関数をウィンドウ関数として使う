# これはエラーになってしまった
・4列目にSUMの類型を出すには、どうすれば良いのか？
shop=# SELECT shohin_mei, shohin_bunrui, hanbai_tanka,
shop-# SUM(hanbai_tanka) FROM shohin;
ERROR:  列"shohin.shohin_mei"はGROUP BY句で指定するか、集約関数内で使用しなければなりません
行 1: SELECT shohin_mei, shohin_bunrui, hanbai_tanka,
             ^

# これはなぜエラーにならないのか？
SELECT shohin_mei, shohin_bunrui, hanbai_tanka,
       SUM(hanbai_tanka) OVER() AS goukei
FROM shohin;

# なぜウィンドウ関数だとエラーにならないのか？
SQLエラーの本当の原因
GROUP BYエラーが起こる理由は、データの粒度（granularity）の違いです。
通常の集約関数の場合
sqlSELECT shohin_mei, SUM(hanbai_tanka) FROM shohin;
SQLの内部処理：

SUM(hanbai_tanka) → テーブル全体を1つのグループとして集約
結果：1行のデータ（合計値のみ）
shohin_mei → 元の8行分のデータが必要

問題： 1行の結果と8行のデータを同時に返せない！
ウィンドウ関数の場合
sqlSELECT shohin_mei, SUM(hanbai_tanka) OVER() FROM shohin;
SQLの内部処理：

元のテーブル構造を保持（8行のまま）
SUM() OVER() → 各行に対して全体の合計を計算
結果：8行のデータ（各行に同じ合計値が追加）

ポイント： 8行の結果と8行のデータで一致している！
視覚的に理解する
通常の集約関数
元データ（8行） → SUM() → 1行の結果
       ↓
shohin_mei（8行）と組み合わせ不可能 ❌
ウィンドウ関数
元データ（8行） → SUM() OVER() → 8行の結果
       ↓
shohin_mei（8行）と組み合わせ可能 ✅
核心
ウィンドウ関数は「行を減らさずに計算する」

通常の集約関数：データを圧縮する（多→少）
ウィンドウ関数：データを拡張する（同じ行数を維持）

だからデータの粒度が一致してエラーにならないのです！

# OVERは各行に対して処理を実行するイメージですか？
OVERは各行に対して処理を実行するイメージで正解です。
具体的な処理イメージ
sqlSELECT shohin_mei, SUM(hanbai_tanka) OVER() FROM shohin;
内部的な処理の流れ
行1: Tシャツ        → SUM(全体) = 16780 を計算して追加
行2: 穴あけパンチ   → SUM(全体) = 16780 を計算して追加  
行3: カッターシャツ → SUM(全体) = 16780 を計算して追加
行4: 包丁          → SUM(全体) = 16780 を計算して追加
...
行8: ボールペン     → SUM(全体) = 16780 を計算して追加
通常の集約関数との違い
通常のSUM（全体を1つにまとめる）
全8行 → SUM() → 1つの結果（16780）
ウィンドウ関数のSUM（各行で同じ計算を実行）
行1 → SUM() OVER() → 16780
行2 → SUM() OVER() → 16780  
行3 → SUM() OVER() → 16780
...
行8 → SUM() OVER() → 16780
だから

元の行数は保たれる（8行→8行）
各行に計算結果が追加される
GROUP BYが不要

# なぜこれだと類型になるのですか？
shop=# SELECT shohin_mei, shohin_bunrui, hanbai_tanka,
shop-# SUM(hanbai_tanka) OVER(ORDER BY shohin_id) FROM shohin;
   shohin_mei   | shohin_bunrui | hanbai_tanka |  sum
----------------+---------------+--------------+-------
 Tシャツ        | 衣服          |         1000 |  1000
 穴あけパンチ   | 事務用品      |          500 |  1500
 カッターシャツ | 衣服          |         4000 |  5500
 包丁           | キッチン用品  |         3000 |  8500
 圧力鍋         | キッチン用品  |         6800 | 15300
 フォーク       | キッチン用品  |          500 | 15800
 おろしがね     | キッチン用品  |          880 | 16680
 ボールペン     | 事務用品      |          100 | 16780
(8 行)

ORDER BYがある場合とない場合の違い
❶ ORDER BY なし（全体の合計）
sqlSUM(hanbai_tanka) OVER()
→ 全行で同じ値（16780, 16780, 16780...）
❷ ORDER BY あり（累積合計）
sqlSUM(hanbai_tanka) OVER(ORDER BY shohin_id)
→ 上から順番に累積（1000, 1500, 5500...）
内部的な処理イメージ
ORDER BYがあると、**「現在行までの合計」**を計算します：
行1（shohin_id=0001）: 1000まで          → 1000
行2（shohin_id=0002）: 1000+500まで      → 1500  
行3（shohin_id=0003）: 1000+500+4000まで → 5500
行4（shohin_id=0004）: ↑+3000まで       → 8500
行5（shohin_id=0005）: ↑+6800まで       → 15300
...
ウィンドウの範囲が変わる
ORDER BY なし
各行での計算範囲 = 全テーブル（固定）
ORDER BY あり
行1での計算範囲 = 1行目まで
行2での計算範囲 = 1〜2行目まで  
行3での計算範囲 = 1〜3行目まで
...
つまり
ORDER BY句があると「ここまでの累積」になる

ORDER BY = 並び順の指定
ウィンドウ関数 = その順番で「上から現在行まで」を計算範囲とする

だから累積（ランニング・トータル）になるんです！

# これは1行目から足していく
shop=# SELECT shohin_mei, shohin_bunrui, hanbai_tanka,
shop-# SUM(hanbai_tanka) OVER(ORDER BY shohin_id) FROM shohin;
   shohin_mei   | shohin_bunrui | hanbai_tanka |  sum
----------------+---------------+--------------+-------
 Tシャツ        | 衣服          |         1000 |  1000
 穴あけパンチ   | 事務用品      |          500 |  1500
 カッターシャツ | 衣服          |         4000 |  5500
 包丁           | キッチン用品  |         3000 |  8500
 圧力鍋         | キッチン用品  |         6800 | 15300
 フォーク       | キッチン用品  |          500 | 15800
 おろしがね     | キッチン用品  |          880 | 16680
 ボールペン     | 事務用品      |          100 | 16780
(8 行)

# 他の関数でも同じこと
shop=# SELECT shohin_mei, shohin_bunrui, hanbai_tanka,
shop-# AVG(hanbai_tanka) OVER(ORDER BY shohin_id) FROM shohin;
   shohin_mei   | shohin_bunrui | hanbai_tanka |          avg
----------------+---------------+--------------+-----------------------
 Tシャツ        | 衣服          |         1000 | 1000.0000000000000000
 穴あけパンチ   | 事務用品      |          500 |  750.0000000000000000
 カッターシャツ | 衣服          |         4000 | 1833.3333333333333333
 包丁           | キッチン用品  |         3000 | 2125.0000000000000000
 圧力鍋         | キッチン用品  |         6800 | 3060.0000000000000000
 フォーク       | キッチン用品  |          500 | 2633.3333333333333333
 おろしがね     | キッチン用品  |          880 | 2382.8571428571428571
 ボールペン     | 事務用品      |          100 | 2097.5000000000000000
(8 行)

# ORDER BYがないと全体が処理対象になってしまう
shop=# SELECT shohin_mei, shohin_bunrui, hanbai_tanka,
shop-# AVG(hanbai_tanka) OVER() FROM shohin;
   shohin_mei   | shohin_bunrui | hanbai_tanka |          avg
----------------+---------------+--------------+-----------------------
 Tシャツ        | 衣服          |         1000 | 2097.5000000000000000
 穴あけパンチ   | 事務用品      |          500 | 2097.5000000000000000
 カッターシャツ | 衣服          |         4000 | 2097.5000000000000000
 包丁           | キッチン用品  |         3000 | 2097.5000000000000000
 圧力鍋         | キッチン用品  |         6800 | 2097.5000000000000000
 フォーク       | キッチン用品  |          500 | 2097.5000000000000000
 おろしがね     | キッチン用品  |          880 | 2097.5000000000000000
 ボールペン     | 事務用品      |          100 | 2097.5000000000000000
(8 行)
